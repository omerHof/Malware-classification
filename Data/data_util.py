import torch
from torch.utils.data import Dataset, DataLoader, ConcatDataset
import numpy as np
from tqdm import tqdm
import cv2
import os
import random
import torchvision.transforms as transforms
import imutils

MALWARE_CLASSES = ['agenttesla', 'berbew', 'coinminer', 'dridex', 'emotet', 'formbook', 'lokibot', 'ramnit', 'trickbot']
# MALWARE_CLASSES = ['Lolyda.AA2', 'Lolyda.AA3', 'Allaple.A', 'C2LOP.P', 'Lolyda.AA1', 'Dontovo.A', 'Lolyda.AT',
#                    'Malex.gen!J', 'Allaple.L', 'Agent.FYI', 'Autorun.K', 'Adialer.C', 'Dialplatform.B', 'Instantaccess',
#                    'Alueron.gen!J', 'C2LOP.gen!g', 'Fakerean', 'Yuner.A', 'Wintrim.BX', 'VB.AT', 'Swizzor.gen!I',
#                    'Swizzor.gen!E', 'Skintrim.N', 'Rbot!gen', 'Obfuscator.AD']
class Data_handler():
    def __init__(self,data_root_path,data_task):
        super().__init__()
        self.data_root_path=data_root_path
        self.class_names_label = {class_name: i for i, class_name in enumerate(MALWARE_CLASSES)}

    def init_dataset(self):
        image_paths = []
        image_labels =[]
        for image_folder in os.listdir(self.data_root_path):
            image_folder_path = os.path.join(self.data_root_path,image_folder)
            for image_file in os.listdir(image_folder_path):
                image_paths.append(os.path.join(self.data_root_path,image_folder,image_file))
                image_labels.append(image_folder)

        return image_paths,image_labels


    def shuffle_arrays(self,image_paths,image_labels):
        joined_dataset =list(zip(image_paths, image_labels))
        random.shuffle(joined_dataset)
        return zip(*joined_dataset)

    def transformation(self):
        transform = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((224, 224))

            # transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])
        return transform


class Classification_dataset(Data_handler,Dataset):

    def __init__(self,data_root_path):
        super(Data_handler,self).__init__()
        self.data_root_path = data_root_path
        self.image_paths, self.image_labels = self.init_dataset()
        self.image_paths, self.image_labels = self.shuffle_arrays(self.image_paths, self.image_labels)
        self.class_names_label = {class_name: i for i, class_name in enumerate(MALWARE_CLASSES)}

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        image = cv2.imread(self.image_paths[idx])
        transformation = self.transformation()
        image = transformation(image)
        label = self.class_names_label[self.image_labels[idx]]

        return image,label



class Triplet_loss_dataset(Data_handler,Dataset):

    def __init__(self,data_root_path):
        super(Data_handler,self).__init__()
        self.data_root_path = data_root_path
        self.image_paths, self.image_labels = self.init_dataset()
        self.anchors,self.positives,self.negatives = self.init_triplets(self.image_paths, self.image_labels)
        self.class_names_label = {class_name: i for i, class_name in enumerate(MALWARE_CLASSES)}

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        transformation = self.transformation()
        anchor_image,anchor_label = self.fetch_image_and_label(self.anchors,idx)
        positive_image,positive_label = self.fetch_image_and_label(self.positives,idx)
        negative_image,negative_label = self.fetch_image_and_label(self.negatives,idx)
        anchor_image = transformation(anchor_image)
        positive_image = transformation(positive_image)
        negative_image = transformation(negative_image)
        return anchor_image,anchor_label,positive_image,positive_label, negative_image,negative_label

    def init_triplets(self, image_paths, image_labels):
        anchors = list(zip(image_paths, image_labels))
        anchors.sort()
        positives = []
        negatives = []
        for label in tqdm(MALWARE_CLASSES,desc ="Generating pairs"):
            min_index,max_index = self.find_label_indexes(label)
            for idx in range(max_index,min_index-1,-1):
                positive_image,positive_label = self.generate_positive_pair(idx)
                positives.append((positive_image,positive_label))
                negative_image,negative_label = self.generate_negative_pair(min_index,max_index)
                negatives.append((negative_image,negative_label))
        
        return anchors,positives,negatives
    
    def fetch_image_and_label(self,dataset,idx):
        self.zip = zip(*dataset)
        images,labels = self.zip
        image = cv2.imread(images[idx])
        # image = cv2.resize(image, (224, 224))
        label = self.class_names_label[labels[idx]]
        return image,label

    def find_label_indexes(self, label):
        indices = np.where(np.array(self.image_labels) == label)[0]
        indices.sort()
        return indices[0],indices[-1]

    def generate_positive_pair(self, idx):
        return self.image_paths[idx],self.image_labels[idx]

    def generate_negative_pair(self, invalid_range_start, invalid_range_end):
        valid_indices = [i for i in range(0, len(self.image_labels)) if
                         i < invalid_range_start or i > invalid_range_end]

        random_index = random.choice(valid_indices)
        return self.image_paths[random_index],self.image_labels[random_index]


# if __name__ == '__main__':
    # data_root_path = '/dt/shabtaia/dt-fujitsu-explainability/Omer/Attack_detection_course/malware_img_dataset'
    # Triplet_loss_dataset(data_root_path)