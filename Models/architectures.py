
import torch
import torch.nn as nn
import torchvision.models as models
import torch.nn.functional as F

class classification_model_architecture():
    def __init__(self, cfg):
        self.cfg = cfg
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = self.init_model(self.cfg.model_params['model_arch'])

    def init_model(self, net_name):

        # Define a dictionary to map net names to their corresponding architectures
        architectures = {
            'resnet18': self.resnet_18,
            'resnet34': self.resnet_34,
            'resnet50': self.resnet_50,
            'resnet101': self.resnet_101,
            'vit':self.vit
        }
        model = architectures[net_name]()
        # Freeze the pre-trained layers
        for param in model.parameters():
            param.requires_grad = False

        # Replace the last fully connected layer with a new one
        if not net_name=='vit':
            num_features = model.fc.in_features
            out_features = self.cfg.model_params['num_of_classes'] if self.cfg.mode=='classification' else self.cfg.model_params['embedding_size']
            model.fc = nn.Linear(num_features, out_features,bias=True)
        else:
            model.heads.head = nn.Linear(model.heads.head.in_features, self.cfg.model_params['num_of_classes'])

        # Move model to the device
        return model.to(self.device)

    def resnet_18(self):
        return models.resnet18(pretrained=True)

    def resnet_34(self):
        return models.resnet34(pretrained=True)

    def resnet_50(self):
        return models.resnet50(pretrained=True)

    def resnet_101(self):
        return models.resnet101(pretrained=True)

    def inception_v3(self):
        return models.inception.Inception3(pretrained=True)

    def vit(self):
        return models.vit_h_14()


class siamese_model_architecture():
    def __init__(self, cfg):
        self.cfg = cfg
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = self.init_model(cfg)

    def init_model(self, cfg):
        return Siamese(cfg)


class Siamese(nn.Module):
    def __init__(self,cfg):
        super(Siamese, self).__init__()
        self.model = classification_model_architecture(cfg)

    def forward(self, anchor, positive, negative):
        out1 = self.model.model(anchor)
        out2 = self.model.model(positive)
        out3 = self.model.model(negative)
        return out1, out2, out3

# Define the triplet loss function
class TripletLoss(nn.Module):
    def __init__(self, margin=1.0):
        super(TripletLoss, self).__init__()
        self.margin = margin

    def forward(self, anchor, positive, negative):
        # distance_positive = (anchor - positive).pow(2).sum(1)
        # distance_negative = (anchor - negative).pow(2).sum(1)
        distance_positive = torch.pairwise_distance(anchor, positive)
        distance_negative = torch.pairwise_distance(anchor, negative)
        losses = F.relu(distance_positive - distance_negative + self.margin)
        return losses.mean()